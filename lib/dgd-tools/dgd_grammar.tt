grammar DGDGrammar
  rule source_file
    ws (inherit ws)* (top_level_decl ws)*
  end

  rule inherit
    ("private" WS)? "inherit" WS (ident WS)? ('object' WS)? string_exp ws ';' <Inherit>
  end

  rule top_level_decl
    data_decl / func_decl
  end

  rule ident
    [a-zA-Z_] [a-zA-Z_0-9]* <Identifier>
  end

  rule c_comment
    '/*'
    (
      !'*/'
      (. / "\n")
    )*
    '*/' <CComment>
  end

  rule quoted_string
    '"' (
      (!["\n\\] ) . /
      "\\" .
    )+ '"' <StringLiteral>
  end

  rule single_WS
    [ \t\v\f\r\n] / c_comment
  end

  rule ws
    single_WS*
  end

  rule WS
    single_WS+
  end

  rule string_exp
    quoted_string /
    '(' ws composite_string ws ')'
  end

  rule composite_string
    string_exp / string_exp '+' composite_string
  end

  rule klass
    (class_spec WS)* class_spec
  end

  rule class_spec
    'private' / 'static' / 'atomic' / 'nomask' / 'varargs'
  end

  rule type_spec
    'int' / 'float' / 'string' / 'object' / 'mapping' / 'mixed' / 'void'
  end

  rule stars
    ('*' ws)*
  end

  rule formals
    # If you put these in a different order with '' and 'void' first, parses start failing. That seems bad.
    formal_list (ws '...')? / '' / 'void'
  end

  rule formal_list
    formal (ws ',' ws formal)*
  end

  rule formal
    class_type data_declarator /
    ident
  end

  rule data_decl
    class_type WS declarators ws ';' <DataDecl>
  end

  rule func_decl
    class_type WS function_declarator ws compound_statement <FuncDecl> /
    klass WS function_name ws '(' ws formals ws ')' ws compound_statement <FuncDecl>
  end

  rule class_type
    (class_spec WS)* type_spec /
    (class_spec WS)* 'object' list_exp
  end

  rule data_declarator
    stars ws ident
  end

  rule function_name
    ident /
    'operator' ws '+' /
    'operator' ws '-' /
    'operator' ws '*' /
    'operator' ws '/' /
    'operator' ws '%' /
    'operator' ws '&' /
    'operator' ws '^' /
    'operator' ws '|' /
    'operator' ws '<' /
    'operator' ws '>' /
    'operator' ws '>=' /
    'operator' ws '<=' /
    'operator' ws '<<' /
    'operator' ws '>>' /
    'operator' ws '~' /
    'operator' ws '++' /
    'operator' ws '--' /
    'operator' ws '[' ws ']' /
    'operator' ws '[' ws ']' ws '=' /
    'operator' ws '[' ws '..' ws ']'
  end

  rule function_declarator
    stars ws function_name ws '(' ws formals ws ')'
  end

  rule declarator
    function_declarator / data_declarator
  end

  rule declarators
    declarator (ws ',' ws declarator)*
  end

  rule compound_statement
    '{' func_to_end_brace
  end

  # This attempts a non-greedy match by first grabbing up to the
  # first end-curly-brace, then successively tries later and later
  # curlies. Does it work?
  rule func_to_end_brace
    (![}] (. / "\n"))* '}' /
    (![}] (. / "\n"))* '}' func_to_end_brace
  end

end
